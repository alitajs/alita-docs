---
title: alita 微应用
order: 10
nav:
  title: 微应用(beta)
  order: 6
  hidden: true
hero:
  title: alita 微应用
  desc: 使用 H5 实现的私域的小程序方案
  actions:
    - text: 开发文档
      link: /micro/dev
features:
  - icon: https://gw.alipayobjects.com/zos/bmw-prod/881dc458-f20b-407b-947a-95104b5ec82b/k79dm8ih_w144_h144.png
    title: 多端上线
    desc: 一个微应用包可以在多个主应用中上线
  - icon: https://gw.alipayobjects.com/zos/bmw-prod/d60657df-0822-4631-9d7c-e7a869c2f21c/k79dmz3q_w126_h126.png
    title: 高性能
    desc: 产物包更小，启动时间更短
  - icon: https://gw.alipayobjects.com/zos/bmw-prod/d1ee0c6f-5aed-4a45-a507-339a4bfe076c/k7bjsocq_w144_h144.png
    title: 原生能力支撑
    desc: 只需一点JavaScript就可以轻松访问本机设备功能
---

# 微应用

微应用是一种类似于微服务的架构，它将微服务的理念应用于原生端，即将应用由单一的原生应用转变为原生主应用与多个小型微应用聚合为一的应用。各个微应用还可以独立运行、独立开发、独立部署。微应用仓库独立，前后端可独立开发，部署完成后主应用自动完成同步更新。

在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略。

## 微应用架构

微应用的实现意味着对前端应用的拆分。拆分应用最显著的目的是可以提升开发效率。比如 10 万行的代码拆解成 10 个项目，每个项目 1 万行代码，要独立维护每个项目就会容易的多。而我们只需要实现应用的自治，即实现应用的独立开发和独立部署，就可以在某种程度上实现微应用架构的目的。

### 1. 应用自治

微应用架构，是多个应用组件的统一应用，这些应用可以交由多个团队来开发。要遵循统一的接口规范或者框架，以便于系统集成到一起，因此相互之间是不存在依赖关系的。我们可以在任意时候，替换其中的任意一个应用，而整体不受影响。这也意味着，我们可以使用各式各样的前端框架，而不会相互影响。

### 2. 与技术栈无关

虽然在默认的方案中，我们提供了使用 alita 框架快速接入微应用的方法，你可能只需要修改一个配置项，就可以将一个现有的 alita 项目，使用微应用的方式，接入到主应用中。但是，其实微应用方法的实现，与技术栈无关，你只需要手动接入 alita sdk，和一些简单的项目事件和生命周期处理即可。

### 3. 单一职责

与微服务类似的是，微应用架构理应满足单一职责的原则。因此要求微应用之间业务关联较少，或者无关联。「技术栈无关」是架构上的准绳，具体到实现时，对应的就是：应用之间不应该有任何直接或间接的技术栈、依赖、以及实现上的耦合。

## 为什么需要微应用

除了上面提到的优点，其实还有其他理由让我们去采用微应用架构：

- 遗留项目迁移
- 聚合前端应用

### 1. 遗留项目迁移

可能是使用 jq、ionic、vue 等框架所编写的单页面应用，已经在线上稳定地运行，也没有新的需求。对于这样的应用来说，我们也没有理由浪费时间和精力重写旧的需求。由于项目已经不更新（不增加新功能或者不再维护），因此这些应用我们统称为遗留项目。既然应用可以使用，就不再花太大的力气重写，而是直接整合到新的应用中去。

不重写原有系统，同时抽出人力来开发新的业务，这对于业务人员来说是一种相当有吸引力的特性，而且对于技术人员来说，也是一件相当不错的事情。

### 2. 后端解构，前端聚合

后段微服务的初期有一个很大的卖点：使用不同的语言、技术栈来开发后台应用。事实上，在同一个团队中对于框架和语言的选型要求比较严格，如在内部限定了语言和框架。因此充分使用不用的技术栈，以发挥微服务的优势，几乎是很少出现的。在这些大型组织机构中，采用微服务的原因主要还是使用微服务架构可以解构服务间的依赖。

而在微前端上，则恰恰与之相反，人们更想要的结果是聚合前端应用，尤其是 To B 的应用。

最近几年，移动应用出现了一种趋势，即用户不想装那么多应用了。而一家大的公司，往往会提供一系列的应用。这些应用从某种程度上反映了这家公司的组织架构。然而，在用户的眼里，他们就是一家公司的，他们就只应该有一个产品。聚合成为客户端的一个技术趋势，实现前端聚合的就是微应用架构。

## 微应用化

微应用化是指，在开发时应用都是以单一、微小应用的形式存在的，而在运行时，则通过构建系统合并这些应用，并组合成一个新的应用，其架构如图所示：

![](https://github.com/phodal/aofe.images/raw/master/ch09/mapp.jpg)

## 架构设计

### 架构基础设施

在基础设施上，微应用架构与单体应用架构有相当大的差异。在单体应用里，共享层往往只有一个。而在微应用架构里，共享层往往存在多个，有的是应用间共用的共享层，有的是应用内共用的共享层。在微应用的架构设计时，构建基础设施要做如下几件事情：

- 组件。在微应用的开发中，统一使用 antd-mobile 作为基础组件库，使用 alita 方案中提供的业务组件和通用的函数功能模块。
- 通信机制。设计应用间的通信机制，并提供相应的底层库支持，结合微应用的生命周期，通过事件和回调的方式进行通信。
- 数据机制。对于微应用需要的数据，采用由微应用独立主动获取启动数据的方式，来管理微应用需要的前置数据，微应用中需要的业务数据，则交由微应用内部独立管理。比如单点登录的接入，由微应用向主应用获取授权信息，然后实际的实现和交互方式，则由微应用和它自己的服务端进行约定。
- 专用的构建框架。使用 alita 微应用方案既可以构建出每个单独的微应用，又可以构建出单独的完整应用。

## 设计理念

### 中心化：应用注册表

微服务从本质上说应该是去中心化的。但是，它又不能完全去中心化。因为对于一个微服务来说，它需要一个服务注册中心：服务提供方要注册通告服务地址，服务的调用方要发现目标服务。

对于一个主应用来说，我们也拥有一个应用注册表，它将拥有每个应用及对应的入口。它标记着对应的应用映射。这个注册表统一交由微应用管理后台自动生成，在 SDK 中会自动获取和记录，在主应用的对接中，只需要获取最新的应用注册表，而无需理会应用的更新和迭代。

微应用在构建完成，上传到微应用管理后台后，会自动在这个应用注册表中注册，SDK 会在每次主应用启动时，及时的更新本地的应用注册表。

这个注册表其实就是一个 JSON 文件，它统一管理应用，能够及时告知主应用，目前存在哪些应用。主应用可以自由的根据数据渲染微应用入口的表现方式。

### 标识化应用

标识化应用是指，建立某种规则来区分不同的应用，类似于唯一标识符，即 appId。我们需要这个唯一标识符来标识不同的应用，以便在安装和卸载的时候，能寻找到指定的应用。

由于微应用上传是绑定到一个特定的主应用下，即它们为同一个组织。由于在同一个组织下，不可能有两个项目的名称是一样的。既然如此，那么就有开发人员为开发应用指定一个唯一的 appId 即可。

> 这与应用独立构建成 app 的行为保持一直，都是通过配置 packageId、 displayName 来完成的。

### 约定的默认行为

容器在打开微应用时，会先判断微应用是否在本地存在。如果存在会直接打开微应用，如果不存在则会先安装该微应用。因此在打开的微应用未安装的情况下，会有一个加载中的画面，这个画面的标题会默认使用微应用的 name 和 icon 进行展示。

容器会自动读取微应用的 document.title 来自动的更新导航栏的标题，因此设置导航栏仅需设置导航类的颜色和属性。

导航栏的右上角功能区，会默认存在一个关闭微应用的按钮和和可能存在的微应用方案功能按钮。因此无法提供在业务上可用的导航栏功能按钮。这个需要在 UI 设计中移除。所有的导航栏按钮设置，都将被忽略（即配置无效化）

导航栏左侧的返回按钮，会自动根据微应用当前路由是否可返回而自动的显示隐藏。因此微应用开发中也无需理会。但同时提供晴空浏览器历史的能力，在类似“返回首页”这样的场景下，需要手动清楚历史。

### 生命周期

当用户打开某个微应用时，在这个过程中，还需要加载动画来响应用户的行为，并自动安装和运行微应用。当用户不需要这个应用时，我们可以选择卸载应用，或者继续保留应用。这一系列步骤所做的事情，就是应用的生命周期。

微应用作为一个客户端应用拥有自己的生命周期，生命周期包括如下 3 个部分：

- 加载应用，运用运行完成时，会响应 AlitaBridgeReady，表示所有的微应用环境以就绪，可以允许用户使用微应用。
- 运行应用，运行中的项目需要响应一些 app 行为，比如应用被压到后台等。
- 卸载应用，应用被关闭时，会响应 AlitaBridgeClose。一般无需理会该事件。

### 高内聚，低耦合

最后，在设计各个微应用及主应用的过程中，需要遵循高内聚、低耦合的原则。

高内聚，即微应用内的关系，一个微应用只由相关性很强的业务组成。设计的过程就是识别、度量业务之间的联系，再将相关的功能模块聚集在一起，把不相关的操作行为放到别处。如果想完成某一个业务的交付，只需要构建和发布一个微应用。在实践的过程中，主要基于单一职责和关注点分离两个原则来实现。

低耦合，即微应用间的关系。对于微应用架构来说，在服务之间、应用之间如果是下了低耦合，那么修改一个服务和应用就不需要修改另一个服务和应用。除了主应用，每个应用都不应该关心其他微应用的相关信息。

## 参考文献

如果你对微前端比较熟悉，那你可以很容易的理解微应用的概念，它就是一个面向原生端的微前端方案的实现。文中提到的概念和内容大量的参考了以下文献。

- [微前端的那些事儿](https://github.com/phodal/microfrontends)
- [Micro Frontends](https://micro-frontends.org/)
- [Micro Frontends from martinfowler.com](https://martinfowler.com/articles/micro-frontends.html)
- [可能是你见过最完善的微前端解决方案](https://zhuanlan.zhihu.com/p/78362028)
- [微前端的核心价值](https://zhuanlan.zhihu.com/p/95085796)
